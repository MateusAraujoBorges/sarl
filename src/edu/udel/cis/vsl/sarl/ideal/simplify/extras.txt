	Interval intervalOfBoundType(BoundType type, boolean isInteger) {
		NumberFactory nf = numberFactory;

		switch (type) {
		case ALL:
			return isInteger ? nf.universalIntegerInterval()
					: nf.universalRealInterval();
		case EMPTY:
			return isInteger ? nf.emptyIntegerInterval()
					: nf.emptyRealInterval();
		case EQ0:
			return nf.singletonInterval(
					isInteger ? nf.zeroInteger() : nf.zeroRational());
		case GE0:
			return nf.newInterval(isInteger,
					isInteger ? nf.zeroInteger() : nf.zeroRational(), false,
					null, true);
		case GT0:
			return nf.newInterval(isInteger,
					isInteger ? nf.zeroInteger() : nf.zeroRational(), true,
					null, true);
		case LE0:
			return nf.newInterval(isInteger, null, true,
					isInteger ? nf.zeroInteger() : nf.zeroRational(), false);
		case LT0:
			return nf.newInterval(isInteger, null, true,
					isInteger ? nf.zeroInteger() : nf.zeroRational(), true);
		}
		throw new SARLInternalException("unreachable");
	}
	
	

	private class ArrayFactComparator implements Comparator<ArrayFact> {

		private Comparator<SymbolicObject> ec;

		ArrayFactComparator(Comparator<SymbolicObject> ec) {
			this.ec = ec;
		}

		@Override
		public int compare(ArrayFact o1, ArrayFact o2) {
			int result = ec.compare(o1.array, o2.array);

			if (result != 0)
				return result;

			int n = o1.boundVars.length;

			result = n - o2.boundVars.length;
			if (result != 0)
				return result;
			for (int i = 0; i < n; i++) {
				result = ec.compare(o1.boundVars[i], o2.boundVars[i]);
				if (result != 0)
					return result;
			}
			result = ec.compare(o1.constraint, o2.constraint);
			if (result != 0)
				return result;
			n = o1.indexExprs.length;
			result = n - o2.indexExprs.length;
			if (result != 0)
				return result;
			for (int i = 0; i < n; i++) {
				result = ec.compare(o1.indexExprs[i], o2.indexExprs[i]);
				if (result != 0)
					return result;
			}
			result = ec.compare(o1.value, o2.value);
			return result;
		}
	}

		/**
	 * Computes the bound type of the given {@link Interval}.
	 *
	 * @param interval
	 *            a non-<code>null</code> {@link Interval}
	 * @return the unique category (instance of {@link BoundType}) into which
	 *         <code>interval</code> falls
	 */
	static BoundType boundType(Interval interval) {
		if (interval.isEmpty())
			return BoundType.EMPTY;

		Number l = interval.lower(), r = interval.upper();
		int lsign = l == null ? -1 : l.signum();
		int rsign = r == null ? 1 : r.signum();

		if (lsign > 0)
			return GT0;
		if (rsign < 0)
			return LT0;

		if (lsign < 0) {
			if (rsign == 0) {
				return interval.strictUpper() ? LT0 : LE0;
			} else { // rsign > 0
				return BoundType.ALL;
			}
		} else { // lsign == 0
			if (rsign == 0) {
				return EQ0;
			} else { // rsign > 0
				return interval.strictLower() ? GT0 : GE0;
			}
		}
	}

	
		GeneralForallStructure getGeneralForallStructure(
			BooleanExpression forallExpr) {
		if (forallExpr.operator() != SymbolicOperator.FORALL)
			return null;

		SymbolicConstant boundVar = (SymbolicConstant) forallExpr.argument(0);
		GeneralForallStructure result = new GeneralForallStructure();
		BooleanExpression forallBody = (BooleanExpression) forallExpr
				.argument(1);
		BooleanExpression constraint, body;

		result.boundVar = boundVar;
		if (!(boundVar instanceof NumericSymbolicConstant)) {
			constraint = trueExpr;
			body = forallBody;
		} else {
			NumericSymbolicConstant var = (NumericSymbolicConstant) boundVar;

			constraint = trueExpr;
			body = falseExpr;
			if (forallBody.operator() == SymbolicOperator.OR) {
				for (SymbolicObject arg : forallBody.getArguments()) {
					BooleanExpression clause = (BooleanExpression) arg;
					BooleanExpression negClause = universe.not(clause);

					if (isLinearInequality(var, negClause))
						constraint = universe.and(constraint, negClause);
					else
						body = universe.or(body, clause);
				}
			} else {
				BooleanExpression negClause = universe.not(forallBody);

				if (isLinearInequality(var, negClause)) {
					constraint = negClause;
					body = falseExpr;
				} else {
					constraint = trueExpr;
					body = forallBody;
				}
			}
		}
		result.constraint = constraint;
		result.body = body;
		return result;
	}

	DeepForallStructure getDeepForallStructure(BooleanExpression forallExpr) {
		GeneralForallStructure struct0 = getGeneralForallStructure(forallExpr);

		if (struct0 == null)
			return null;

		LinkedList<NumericSymbolicConstant> boundVars = new LinkedList<>();
		BooleanExpression constraint = trueExpr;
		BooleanExpression body = null;

		while (struct0 != null) {
			SymbolicConstant x = struct0.boundVar;

			if (!(x instanceof NumericSymbolicConstant))
				return null;
			boundVars.add((NumericSymbolicConstant) x);
			constraint = universe.and(constraint, struct0.constraint);
			body = struct0.body;
			struct0 = getGeneralForallStructure(body);
		}

		DeepForallStructure result = new DeepForallStructure();

		result.boundVars = boundVars
				.toArray(new NumericSymbolicConstant[boundVars.size()]);
		result.constraint = constraint;
		result.body = body;
		return result;
	}
	
	
		// Comparator<ArrayFact> arrayFactComparator;
	
		public Range rangeOf(RangeSign sign, boolean integral) {
		int i = integral ? 0 : 1;

		switch (sign) {
		case ALL: // (-infty,infty)
			return signRanges[i][0];
		case EMPTY: // empty
			return signRanges[i][1];
		case EQ0: // [0,0]
			return signRanges[i][2];
		case GE0: // [0,infty)
			return signRanges[i][3];
		case GT0: // (0,infty)
			return signRanges[i][4];
		case LE0: // (-infty, 0]
			return signRanges[i][5];
		case LT0: // (-infty, 0)
			return signRanges[i][6];
		default:
			throw new SARLException("unreachable");
		}
	}
	
			this.signRanges = new Range[2][];
		signRanges[0] = new Range[] {
				rangeFactory.interval(true,
						numberFactory.infiniteNumber(true, false), true,
						numberFactory.infiniteNumber(true, true), true),
				rangeFactory.emptySet(true),
				rangeFactory.singletonSet(numberFactory.zeroInteger()),
				rangeFactory.interval(true, numberFactory.zeroInteger(), false,
						numberFactory.infiniteNumber(true, true), true),
				rangeFactory.interval(true, numberFactory.zeroInteger(), true,
						numberFactory.infiniteNumber(true, true), true),
				rangeFactory.interval(true,
						numberFactory.infiniteNumber(true, false), true,
						numberFactory.zeroInteger(), false),
				rangeFactory.interval(true,
						numberFactory.infiniteNumber(true, false), true,
						numberFactory.integer(-1), false) };
		signRanges[1] = new Range[] {
				rangeFactory.interval(false,
						numberFactory.infiniteNumber(false, false), true,
						numberFactory.infiniteNumber(false, true), true),
				rangeFactory.emptySet(false),
				rangeFactory.singletonSet(numberFactory.zeroRational()),
				rangeFactory.interval(false, numberFactory.zeroRational(),
						false, numberFactory.infiniteNumber(false, true), true),
				rangeFactory.interval(false, numberFactory.zeroRational(), true,
						numberFactory.infiniteNumber(false, true), true),
				rangeFactory.interval(false,
						numberFactory.infiniteNumber(false, false), true,
						numberFactory.zeroRational(), false),
				rangeFactory.interval(false,
						numberFactory.infiniteNumber(false, false), true,
						numberFactory.zeroRational(), true) };

						
	private SymbolicSequence<?> simplifySequence(SymbolicSequence<?> sequence) {
		SymbolicSequence<?> result = (SymbolicSequence<?>) getCachedSimplification(
				sequence);

		if (result == null) {
			result = simplifySequenceWork(sequence);
			cacheSimplification(sequence, result);
		}
		return result;
	}
	
	
		/**
	 * Is the given expression the "originalAssumption" of {@link #theContext}
	 * or one of the super*-contexts of {@link #theContext}? This is here to
	 * help avoid infinite recursions in the simplification process.
	 *
	 * @param expression
	 *            a boolean expression being simplified and for which you would
	 *            like to know whether it is already
	 *            "on the simplification stack"
	 * @return true iff seen before, else false
	 */
	private boolean seenBefore(BooleanExpression expression) {
		Context c = theContext;

		while (true) {
			// does it matter if c is initialized?
			// reason: suppose you assume p and wish to simplify p.
			// Is this method even necessary anymore?
			if (!c.isInitialized() && c.getOriginalAssumption() == expression)
				return true;
			if (c instanceof SubContext)
				c = ((SubContext) c).getSuperContext();
			else
				return false;
		}
	}
	
	
	